Developers Guide
------------------

This section gives you a brief overview about the structure of GrailsFlow and how the
system works internally.

The most important elements and components are:

    * process definitions
    * processes
    * process variables
    * worklist management


Process Definitions
--------------------

The workflow engine consists of process definitions and the information about running
processes. They define the basic steps of a process. We call these steps nodes.

Process Definitions are stored in Groovy classes using the builder syntax. You find
examples in web-app/WEB-INF/workarea/processes/ in your GrailsFlow directory.

When editing processes, this informations gets parsed and stored into ProcessDef and
ProcessDefNodes. After the editing process GrailsFlow creates new Groovy files from these
definitions.

The node types are:

    * activitiy nodes: the system executes Groovy code that is stored in the node.

    * split node: the engine allows splits so that multiple steps can be executed in parallel.
     Split nodes mark the beginning of a parallel execution.

    * join nodes: this is the counterpart to split nodes, where multiple parallel executions
     are joined together.

    * wait nodes: wait nodes expect user input. When the process excecution reaches a wait
     node, the node becomes visible in the worklist. Typically the user enters/changes
     values of process variables or makes decisions about where to go to next (decides
     for/specifies an event).


We move from node to node via so called "events" (also called transitions). When a node
gets executed it returns a value (name of the event). Based on this value the workflow
engine moves to the next node that is connected via this event.

Processes
-----------

Running Processes as well as historical information is stored in:

    * Process and
    * ProcessNode


Whenever a process enters a new node, a process node record is created in the database.
After the process leaves the nodes, the record gets updated with status information.

This means ProcessNode includes all historical information about the process. When the
process enters the same node twice, there are two records for this node.

This makes it easy to see the status of running or old processes by looking at the process
 and processNodes tables.

Process Variables
-----------------------

ProcessVariables are all public variables declared in the process. The variables are read
via reflection and stored in the ProcessVariable class as a map. Whenever the variables
have changed, they get stored back into the database.

Therefore, process variables are always persisted in the database, so that the process can
go on, even after the application has been restarted. However, process variables do not
include any historic information, only the current values. This is different from nodes,
where we see the complete history in process nodes.

Worklist management
----------------------

GrailsFlow supports automatic execution of nodes and manual user input. Workflows often
need the user to make decisions or give input to the process.

GrailsFlow has functions for worklist management integrated. Whenever a process designer
specifies a wait node, the execution of the process stops when reaching that node. The
node becomes visible in the worklist of the user that is currently assigned to that
process node.

When he clicks on the node there are three possible interactions:

    * automatic forms: the user sees all process variables that the process designer has
      given read access to. He can enter values for variables. GrailsFlow also shows buttons
      for all events/transitions that leave the node, so the user can decide which transition
      to take by clicking on the button.

    * manual form: GrailsFlow allows to upload forms that have been defined manually.
      These forms are shown instead of the automatically generated form.

    * manual forms and controller: This allows process designers to define their own forms
      management and their own controllers. This is the most flexible way of interacting
      with the user, however it is also the biggest effort. Controller can deal with
      process variables or other Grails components and can also span multiple pages using
      the Grails WebFlow functionality.